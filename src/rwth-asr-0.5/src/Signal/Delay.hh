// Copyright 2011 RWTH Aachen University. All rights reserved.
//
// Licensed under the RWTH ASR License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#ifndef _SIGNAL_DELAY_HH
#define _SIGNAL_DELAY_HH

#include "SlidingWindow.hh"
#include <Flow/Node.hh>

namespace Signal {

    /** Packet delay filter.
     * Inputs: one
     * Outputs: many, dynamically generated.  Port name must be
     * positive or negative integer corresponding to the desired delay.
     * Parameters:
     *   -@c max-size is the maximum number of outputs, and
     *   -@c right is the index of the 0 delay from the right side.
     * Output port 0: no delay, i.e. most recent frame
     * Output port t: delay of t frames, i.e. each frame is t *
     * frame-shift older/newer than the current frame on port 0.
     * Margin cases:
     *  -Parameter @c margin-policy defines how missing frames are generated:
     *   copy: missing frames are generated by copying the closest frame.
     *   mean: missing frames are generated by copying the mean frame.
     *   zero: missing frames are generated by adding 0s.
     *   one : missing frames are generated by adding 1s.
     *  -Parameter @c margin-condition defines when the outputs become valid
     *   not-empty: if at least one of the delays contain a frame. This condition ensures
     *              that each input frame can be retrieved at all delays.
     *   present-not-empty: if the delay=0 contains a frame. This condition ensures that
     *                      the number of input frames is equal to the number of output frames.
     *   full: if all the delays contain a frame. This condition ensures that
     *         non of the outputs contains a missing, i.e. a newly generated frame.
     * Note: Time stamps are not changed.
     */
    class DelayNode :
	public Flow::Node,
	public SlidingWindow<Flow::DataPtr<Flow::Data> >
    {
	typedef SlidingWindow<Flow::DataPtr<Flow::Data> > DataSlidingWindow;
    public:
	static const Core::ParameterInt parameterMaxSize;
	static const Core::ParameterInt parameterRight;

	static const Core::Choice choiceMarginPolicyType;
	static const Core::ParameterChoice paramMarginPolicy;

	static const Core::Choice choiceMarginConditionType;
	static const Core::ParameterChoice paramMarginCondition;
    private:
	size_t maxSize_;
	size_t right_;
	marginPolicy *marginPolicy_;
	marginCondition *marginCondition_;
	bool needInit_;
    private:
	void setMaxSize(size_t maxSize) { if (maxSize_ != maxSize) { maxSize_ = maxSize; needInit_ = true; } }
	void setRight(size_t right) { if (right_ != right) { right_ = right; needInit_ = true; } }
	void setMarginPolicy(MarginPolicyType);
	void setMarginCondition(MarginConditionType);
	void init();
	bool putData(Flow::DataPtr<Flow::Data> out);
    protected:
	/** returns the at relative index @param relativeIndex.
	 *  If sliding window does not contain an element at position @param relativeIndex,
	 *  return is an object created by marginPolicy_.
	 */
	void get(int relativeIndex, Flow::DataPtr<Flow::Data> &out) const;
	template<class T> void get(int relativeIndex, Flow::DataPtr<T> &out) const {
	    Flow::DataPtr<Flow::Data> outData; get(relativeIndex, outData);
	    out = outData; ensure(out);
	}

	/** override this function to produce output from the sliding window */
	virtual bool putData();
    public:
	static std::string filterName() { return "signal-delay"; }
	DelayNode(const Core::Configuration &c);
	virtual ~DelayNode();

	virtual bool setParameter(const std::string &name, const std::string &value);
	virtual bool configure();
	virtual Flow::PortId getInput(const std::string &name) { return 0; }
	virtual Flow::PortId getOutput(const std::string &name);
	virtual bool work(Flow::PortId);
    };

} // namespace Signal

#endif //_SIGNAL_DELAY_HH
